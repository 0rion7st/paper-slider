<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
-->

<!--
/**
 * @group Quantum Paper Elements
 *
 * `paper-slider` allows user to select a value from a range of values by
 * moving the slider thumb.  The interactive nature of the slider makes it a 
 * great choice for settings that reflect intensity levels, such as volume, 
 * brightness, or color saturation.
 *
 * Example:
 *
 *     <paper-slider></paper-slider>
 *
 * Use `min` and `max` to specify the slider range.  Default is 0 to 100.
 *
 * Example:
 *
 *     <paper-slider min="10" max="200" value="110"></paper-slider>
 *
 * Styling slider:
 *
 * To change the slider progress bar color:
 *
 *     paper-slider /shadow/ #sliderBar /shadow/ #activeProgress {
 *       background-color: #0f9d58;
 *     }
 *
 * To change the slider knob color:
 *
 *     paper-slider /shadow/ #sliderKnobInner {
 *       background-color: #0f9d58;
 *     }
 *
 * To change the slider pin color:
 *
 *     paper-slider /shadow/ #sliderKnobInner::before {
 *       background-color: #0f9d58;
 *     }
 *
 * To change the slider secondary progress bar color:
 *
 *     paper-slider /shadow/ #sliderBar /shadow/ #secondaryProgress {
 *       background-color: #0f9d58;
 *     }
 *
 * @element paper-slider
 * @homepage github.io
 */
-->

<link rel="import" href="../paper-progress/paper-progress.html">

<polymer-element name="paper-slider" extends="core-range" attributes="snaps pin disabled secondaryProgress">

  <template>
  
    <link rel="stylesheet" href="paper-slider.css">
    <link rel="stylesheet" href="../core-layout/core-layout.css">

    <div id="sliderContainer" touch-action="pan-y">
    
      <paper-progress id="sliderBar" aria-hidden="true" min="{{min}}" max="{{max}}" value="{{_value}}" secondaryProgress="{{secondaryProgress}}"
          on-pointerdown="{{barPointerDown}}" on-pointerup="{{resetKnob}}" 
          on-trackstart="{{trackStart}}" on-track="{{track}}" on-trackend="{{trackEnd}}"></paper-progress>
      
      <template if="{{snaps && !disabled}}">
        <div core-flow class="slider-markers">
          <template repeat="{{markers}}">
            <div core-flex class="slider-marker"></div>
          </template>
        </div>
      </template>
      
      <div id="sliderKnob" core-flow core-align="center" core-justify="center" 
          class="{{ {pin : pin, snaps : snaps} | tokenList }}" 
          on-pointerdown="{{expandKnob}}" on-pointerup="{{resetKnob}}" 
          on-trackstart="{{trackStart}}" on-track="{{track}}" on-trackend="{{trackEnd}}"
          role="slider" aria-valuenow="{{value}}" aria-valuemin="{{min}}" aria-valuemax="{{max}}" tabindex="0">
          
        <div id="sliderKnobInner" value="{{_value}}"></div>
        
      </div>
      
    </div>

  </template>
  
  <script>

    Polymer('paper-slider', {
      
      /**
       * If true, the slider thumb snaps to tick marks evenly spaced based
       * on the `step` property value.
       *
       * @attribute snaps
       * @type boolean
       * @default false
       */
      snaps: false,
      
      /**
       * If true, a pin with numeric value label is shown when the slider thumb 
       * is pressed.  Use for settings for which users need to know the exact 
       * value of the setting.
       *
       * @attribute pin
       * @type boolean
       * @default false
       */
      pin: false,
      
      /**
       * If true, this slider is disabled.  A disabled slider cannot be tapped
       * or dragged to change the slider value.
       *
       * @attribute disabled
       * @type boolean
       * @default false
       */
      disabled: false,
      
      /**
       * The number that represents the current secondary progress.
       *
       * @attribute secondaryProgress
       * @type number
       * @default 0
       */
      secondaryProgress: 0,
      
      observe: {
        'value min max step snaps': 'update'
      },
      
      eventDelegates: {
        keydown: 'keydown'
      },
      
      ready: function() {
        this.update();
      },
      
      attached: function() {
        this._w = this.$.sliderBar.offsetWidth;
      },
      
      update: function() {
        this.validateValue();
        this.positionKnob(this.getPositionFromValue(this.value));
        this.updateMarkers();
      },
      
      calcKnobPosition: function() {
        return (this.max - this.min) * this._x / this._w + this.min;
      },
      
      getPositionFromValue: function(value) {
        return this.calcRatio(value) * this._w;
      },
      
      expandKnob: function() {
        this.$.sliderKnob.classList.add('expand');
      },
      
      resetKnob: function() {
        this.expandJob && this.expandJob.stop();
        this.$.sliderKnob.classList.remove('expand');
      },
      
      positionKnob: function(x) {
        this._x = x;
        var s =  this.$.sliderKnob.style;
        this._value = this.calcStep(this.calcKnobPosition()) || 0;
        s.webkitTransform = s.transform = 'translate(' + (this.snaps ? 
            this.getPositionFromValue(this._value) : x) + 'px, 0)';
        this.$.sliderKnob.classList.toggle('ring', this._value <= this.min);
      },
      
      trackStart: function(e) {
        this._startx = this._x || 0;
        this.$.sliderKnob.classList.add('dragging');
        e.preventTap();
      },

      track: function(e) {
        this.positionKnob(Math.min(this._w, Math.max(0, this._startx + e.dx)));
      },
      
      trackEnd: function() {
        this.$.sliderKnob.classList.remove('dragging');
        this.resetKnob();
        this.value = this.calcStep(this.calcKnobPosition());
      },
      
      barPointerDown: function(e) {
        var rect = this.$.sliderBar.getBoundingClientRect();
        this.positionKnob(e.x - rect.left);
        this.value = this.calcStep(this.calcKnobPosition());
        this.expandJob = this.job(this.expandJob, this.expandKnob, 60);
      },
      
      updateMarkers: function() {
        this.markers = [], l = (this.max - this.min) / this.step;
        for (var i = 0; i < l; i++) {
          this.markers.push('');
        }
      },
      
      increment: function() {
        this.value = this.clampValue(this.value + this.step);
      },
      
      decrement: function() {
        this.value = this.clampValue(this.value - this.step);
      },
      
      keydown: function(e) {
        if (this.disabled) {
          return;
        }
        var c = e.keyCode;
        if (c === 37) {
          this.decrement();
        } else if (c === 39) {
          this.increment();
        }
      }

    });

  </script>

</polymer-element>
